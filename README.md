# OLSQ-DPQA Compiler
Optimal Layout Synthesizer of Quantum Circuits for Dynamically Field-Programmable Qubits Array.
Open source under the BSD 3-Clause license.

Repo structure:
- `run_graph_olsq.py` is an example of using the compiler as in the evaluation in the main text. Refer to `python run.py -h` for options.
- `solve.py` contains the class `DPQA` where we encode the compilation problem to SMT, and use `z3-solver` to solve it.
- `graphs.json` contains all the random 3-regular graphs we used. They are generated by `networkx`.
- `animation.py` contains the class `CodeGen` that generates DPQA instructions (five types `init`, `rydberg`, `activate`, `deactivate`, and `move`), and the class `Animator` that generates animations from DPQA instructions. Refer to `python animation.py -h` for options.
- `get_dpqa_duration.py` generates code files containing DPQA instructions from the SMT results to collect statistics. Refer to `python get_dpqa_duration.py -h` for options.
- `draw.py` generates the figures used in the paper and also calculates some statistics. It takes one necessary argument `small` or `large`. Refer to `python draw.py -h` for options.
- `qasm_benchmarks/` contains the QASM file for the evaluations in the appendix.
- `run_generic_olsq.py` is for the evaluation in the appendix.
- `run_generic_sabre.py` is for the evaluation baseline in the appendix.
- `results/` contains results used in the evaluation of the paper.
  - `results/smt/` contains the output of SMT variable assignments.
    - `results/smt/generic/` contains the output for additional evaluations in the appendix.
  - `results/stats/` contains the statistics of results of compilers (OLSQ-DPQA and others).
    - `results/stats/generic/` contains the statistics for additional evaluations in the appendix.
  - `results/code/` contains the code files generated from SMT output.
  - `results/animations/` contains a few example animations generated from code files.
  - `results/figures/` contains the figures in the paper.

How to reproduce the experiments in main text:
- We used a Python 3 environment with `z3-solver==4.12.1.0`, `networkx==3.0`, and `python-sat==0.1.8.dev1`, and `matplotlib==3.6.2`. The Python scripts are run in the root directory of the repo.
- Run `python run.py <S> <I> --dir <D>` where 
  - `<S>` in `[10, 12, 14, 16, 18, 20, 22, 30, 40, 50, 60, 70, 80, 90]`,
  - `<I>` in `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]`,
  - `<D>` is the directory to save the output. Do not forget the `/` at the end of `<D>`.
- As discussed in the appendix of the paper, graphs `S_I` in `[20_5, 22_5, 22_8, 80_1, 90_0, 90_2, 90_6, 90_8, 90_9]` timed out in our experiments and were not included in the data for the figures.
- Run `python get_dpqa_duration.py --dir <D>` to generate code files in `./animations` and collect statistics of OLSQ-DPQA results.
- Run `python draw.py small` and `python draw.py large`. The numbers we used in the paper will be printed out and the figures will be generated.
- (Optional) To generate animation, run `python animation.py <F>` where `<F>` is the SMT output file, e.g., `results/smt/rand3reg_90_1.json`.

How to reproduce the experiments in appendix:
- Here we need Qiskit to be in the environment. We used version 0.42.1. Then, just do `python run_generic_sabre.py`.
  - A file named `sabre_2q` is generated containing SABRE result statistics of the benchmarks.
  - Another file named `only_2q.json` is generated containing the list of two-qubit gates for each benchmark. We need this to run OLSQ-DPQA.
- `python run_generic_olsq.py <F>` where `F` is one of the files in `qasm_benchmarks/`. 
  - All benchmarks can be run simutaneously with, e.g., `for file in qasm_benchmarks/* ; do python run_generic_olsq.py $file & done`.
  - The statistics of OLSQ-DPQA results will be accumulated to a file named `olsq_2q`.


Explaination of `run_graph_olsq.py`:
- The main class is named `DPQA` which is in `solve.py`. 
  - When we initialize it, there is a mandatory argument `name` which is used for saving output file (a JSON containing SMT variables).
  - Optionally, you can specify the directory for this file with argument `dir`.
  - There is another optional argument `print_detail` to specify the granularity of printout.
- We need to specify the architecture with `setArchitecture` method of `DPQA`. It takes in a list of 4 numbers, which are the number of columns of interaction sites, the number of rows of interaction sites, the number of AOD columns, and the number of AOD rows.
- We need to specify the two-qubit gates in a list with `setProgram` method of `DPQA`. For example, a circuit CZ(0,1), CZ(1,2), CZ(0,1) will be `[[0,1], [1,2], [0,1]]`.
- If all the gates are commutable with each other (e.g., the two-qubit gates in an iteration of QAOA), call the `setCommutation` method of `DPQA`. Otherwise, do not call it and the compiler will process the gates considering dependency.
- We can set the ratio of switching from interative peeling to optimal (multi-stage) solving with `setOptimalRatio` method of `DPQA`. By default, the ratio is 0.
- Finally, we can solve the formulated SMT problem with the `solve` method of `DPQA`.